#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import os
from typing import List, Dict
import logging
import kserve
import http.client
import json
import numpy as np
#import pandas as pd
import datetime
#os.system('pip3 install scikit-learn')
# from sklearn.preprocessing import MinMaxScaler


class MyTransformer(object):
    """
    user defined transformer
    This is an example.
    Preprocess and postprocess are required methods.
    This class will be used in such way:
    1. framework instantiate this class.
        in this step,user usually do some preparation work(e.g.,load global configuration).
    2. framework call preprocess method on instance mentioned above.
    3. framework request predictor with result of step2.
    4. framework call postprocess method on instance of step1 and pass result of step3 to postprocess.
    """
    def __init__(self, context: Dict):
        """
        initialize a instance

        Args:
            context: environment variables passed by caller
        """
        # data_path point to outer data path
        # data_path = context['data_path']
        # # feature_type.txt and feature_value.txt are generated by user
        # fea_type_file = os.path.join(data_path, 'feature_type.txt')
        # fea_value_file = os.path.join(data_path, 'feature_value.txt')
        # list of feature type pair

        # dict of feature values pair


    def data_transform(self,instance):
        """converts the input json into list
        Args:
            instance (json): The request input for json.
        Returns:
            list: Returns converted tensor as input for predict handler with v1/v2 inference protocol.
        """

        logging.info(type(instance)) #instance type is json
        logging.info(instance)
        #input = instance[0].get("data") or instance[0].get("body")

        # input = input.decode('utf8')
        # input = json.loads(input)
        data = instance["instances"]
        #归一化
        # scaler = MinMaxScaler()
        # scaler.data_max_ = np.array(
        #     [4., 14., 6., 23., 27.2820034, 2.71147953, 1.0387648, 2.99734569, 2.99132275, 327.55831909, 29.20000839,
        #    ], dtype='float64')
        # scaler.data_min_ = np.array([4., 7., 0., 0., 0.30000004, 0., 0., 0., 0., 9.84292221, 0.], dtype='float64')
        # scaler.fit_transform(np.numpy(data))
        data_max = np.array(
            [4., 14., 6., 23., 27.2820034, 2.71147953, 1.0387648, 2.99734569, 2.99132275, 327.55831909, 29.20000839])
        data_min = np.array([1., 7., 0., 0., 0.30000004, 0., 0., 0., 0., 9.84292221, 0.])
        data_norm = (np.array(data) - data_min) / (data_max - data_min)
        data_norm = data_norm.tolist()
        logging.info(type(data_norm))
        logging.info(data_norm) #data_norm type is list

        return data_norm

    def preprocess(self, inputs):
        """
        Args:
            inpus type (json):
        Returns:
            preprocessed_data type (dict):
        """
        data = self.data_transform(inputs) #data type is list
        preprocessed_data = {'instances': data} #preprocessed_data type is dict
        logging.info(preprocessed_data)

        #torchserve即predictor接收的数据统一格式为{"instances":data},predictor会
        #自动取出"instances"所对应的data，to_tensor后进行推理.
        return preprocessed_data


    def postprocess(self, inputs: Dict) -> Dict:
        logging.info("The output from model predict is %s", inputs)
        '''
        if self.protocol == "grpc-v2":
            response = InferResult(inputs)
            return response.get_response(as_json=True)
        elif self.protocol == "http":
            pass
        '''
        return inputs
